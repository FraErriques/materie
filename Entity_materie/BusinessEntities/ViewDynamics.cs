using System;
using System.Collections.Generic;
using System.Text;


namespace Entity_materie.BusinessEntities
{

    public static class ViewDynamics
    {
        /// <summary>
        /// an internal class. Not inheritable. It has a Destructor, since it's not static. But it is istantiated through a 
        /// static variable, so its Destructor is executed on AppDomainDrop.
        /// </summary>
        public sealed class DoViewDestruction
        {// Destructor here is just a neme, to remember that it will be executed at the end of the static object (Foo) that holds it.
            public System.Collections.ArrayList viewNames;
            public string lastGeneratedView;


            public DoViewDestruction(// in spite of its name, it's a Constructor().
              )// in spite of its name, it's a Constructor().
            {// Ctor()
                if (null == this.viewNames)
                {
                    this.viewNames = new System.Collections.ArrayList();// allocate the View name store.
                }// else it's already been cnstructed.
            }// Ctor()


            public void addView(string viewName_par)
            {
                this.viewNames.Add(viewName_par);
                this.lastGeneratedView = viewName_par;
            }


            ~DoViewDestruction()
            {// One time only destructor. Use it to drop the application-db-Views.
                for (int c = 0; c < this.viewNames.Count; c++)
                {// delete view, generated by localhostApp.
                    Entity_materie.Proxies.usp_ViewCacher_generic_DROP_SERVICE.usp_ViewCacher_generic_DROP(
                        Entity_materie.FormatConverters.ViewNameDecorator_SERVICE.ViewNameDecorator(
                            (string)(this.viewNames[c]))
                    );
                }
            }// ~DoViewDestruction()


        }// class DoViewDestruction
        //


        // a static variable, of the non-static internal class DoViewDestruction. Being a static variable, it will be dropped on AppDomainDrop.
        // but being non static in type, it can contain a Destructor, whose code executes what we need to do on AppDomainDrop.
        public static readonly DoViewDestruction Finalise;

        static ViewDynamics()
        {// One time only constructor. Cannot be called explicitly.
            Finalise = new DoViewDestruction();
        }


        /// <summary>
        /// this method composes the viewName from the themeDecoration plus a timeSeededSuffix.
        /// </summary>
        /// <param name="themeDecoration"></param>
        public static void accessPoint(string themeDecoration)
        {
            string theWholeName = themeDecoration;
            theWholeName +=
                DateTime.Now.Year.ToString()
                + "|"
                + DateTime.Now.Month.ToString()
                + "|"
                + DateTime.Now.Day.ToString()
                + "#"
                + DateTime.Now.Hour.ToString()
                + ":"
                + DateTime.Now.Minute.ToString()
                + ":"
                + DateTime.Now.Second.ToString()
                + "#"
                + DateTime.Now.Millisecond.ToString();
            //
            Finalise.addView(theWholeName);
        }//


    }// class ViewDynamics


}// nmsp
